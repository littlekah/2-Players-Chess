<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Chess Ult - IA</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">
<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  body {
    font-family: "Poppins", sans-serif;
    background: linear-gradient(135deg, #262421 0%, #1a1815 100%);
    color: #fff;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    padding: 20px;
  }

  h1 {
    color: #81b64c;
    margin-bottom: 20px;
    font-size: 2.4em;
    text-shadow: 0 0 25px rgba(129, 182, 76, 0.6);
    font-weight: 700;
  }

  .game-container {
    display: flex;
    gap: 25px;
    align-items: flex-start;
    flex-wrap: wrap;
    justify-content: center;
  }

  .left-panel {
    display: flex;
    flex-direction: column;
    gap: 15px;
  }

  .game-info {
    background: linear-gradient(135deg, #2c2a26, #1f1d1a);
    padding: 20px;
    border-radius: 12px;
    border: 2px solid #3d3a33;
    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
    min-width: 280px;
  }

  .info-row {
    display: flex;
    justify-content: space-between;
    padding: 10px 0;
    border-bottom: 1px solid #3d3a33;
  }

  .info-row:last-child {
    border-bottom: none;
  }

  .info-label {
    color: #999;
    font-size: 0.95em;
  }

  .info-value {
    color: #fff;
    font-weight: 700;
    font-size: 1.05em;
  }

  .timer-display {
    background: linear-gradient(135deg, #2c2a26, #1f1d1a);
    padding: 15px 20px;
    border-radius: 12px;
    border: 2px solid #3d3a33;
    text-align: center;
    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
  }

  .timer-display .label {
    color: #999;
    font-size: 0.9em;
    margin-bottom: 5px;
  }

  .timer-display .time {
    font-size: 2em;
    font-weight: 700;
    color: #81b64c;
    font-family: 'Courier New', monospace;
  }

  #board {
    display: grid;
    grid-template-columns: repeat(8, 75px);
    grid-template-rows: repeat(8, 75px);
    border: 3px solid #3d3a33;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7);
    border-radius: 4px;
    overflow: hidden;
  }

  .square {
    width: 75px;
    height: 75px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 48px;
    cursor: pointer;
    user-select: none;
    position: relative;
    transition: all 0.2s ease;
  }

  .square:hover {
    filter: brightness(1.1);
  }

  .light {
    background-color: #eeeed2;
  }

  .dark {
    background-color: #769656;
  }

  .highlight {
    box-shadow: inset 0 0 0 4px #f6f669;
    animation: highlightPulse 1.2s infinite;
  }

  @keyframes highlightPulse {
    0%, 100% { box-shadow: inset 0 0 0 4px #f6f669; }
    50% { box-shadow: inset 0 0 0 4px #baca44; }
  }

  .possible-move {
    background-color: rgba(0, 0, 0, 0.15);
    border-radius: 50%;
    width: 24px;
    height: 24px;
    pointer-events: none;
    position: absolute;
    animation: pulse 1.8s infinite;
    border: 2px solid rgba(0, 0, 0, 0.2);
  }

  .possible-capture::after {
    content: "";
    position: absolute;
    width: 100%;
    height: 100%;
    border: 4px solid rgba(0, 0, 0, 0.2);
    border-radius: 50%;
    pointer-events: none;
  }

  .cannon-launch::after {
    content: "üöÄ";
    position: absolute;
    top: -10px;
    right: -10px;
    font-size: 16px;
    animation: pulse 1.8s infinite;
  }

  @keyframes pulse {
    0% { transform: scale(0.9); opacity: 0.7; }
    50% { transform: scale(1); opacity: 1; }
    100% { transform: scale(0.9); opacity: 0.7; }
  }

  .last-move {
    background-color: rgba(246, 246, 105, 0.4) !important;
  }

  .square span {
    filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.4));
    font-size: 52px;
  }

  .king-in-check {
    background: radial-gradient(circle, rgba(255, 0, 0, 0.6) 0%, transparent 70%) !important;
    animation: checkBlink 1s infinite;
  }

  @keyframes checkBlink {
    0%, 100% { filter: brightness(1); }
    50% { filter: brightness(1.3); }
  }

  #turn {
    margin-top: 20px;
    font-size: 1.3em;
    font-weight: 600;
    padding: 12px 28px;
    background: linear-gradient(135deg, #2c2a26, #1f1d1a);
    border-radius: 12px;
    border: 2px solid #3d3a33;
    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
  }

  .button-container {
    display: flex;
    gap: 15px;
    margin-top: 20px;
    flex-wrap: wrap;
    justify-content: center;
  }

  button {
    padding: 14px 28px;
    border: none;
    border-radius: 10px;
    cursor: pointer;
    font-weight: 600;
    font-size: 1em;
    transition: all 0.3s ease;
    font-family: "Poppins", sans-serif;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  }

  button:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 18px rgba(0, 0, 0, 0.5);
  }

  button:active {
    transform: translateY(0);
  }

  #equipCannon {
    background: linear-gradient(135deg, #b58863, #9e7150);
    color: #fff;
    display: none;
  }

  #equipCannon:hover {
    background: linear-gradient(135deg, #c59873, #ae8160);
  }

  #restart {
    background: linear-gradient(135deg, #81b64c, #6a9a3d);
    color: #fff;
  }

  #restart:hover {
    background: linear-gradient(135deg, #91c65c, #7aaa4d);
  }

  #backToMenu {
    background: linear-gradient(135deg, #555, #333);
    color: #fff;
  }

  #backToMenu:hover {
    background: linear-gradient(135deg, #666, #444);
  }

  #promotion, #victoryModal {
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: linear-gradient(135deg, #2c2a26, #1f1d1a);
    border: 3px solid #81b64c;
    border-radius: 16px;
    padding: 35px;
    text-align: center;
    box-shadow: 0 0 60px rgba(129, 182, 76, 0.8);
    z-index: 100;
    min-width: 350px;
  }

  #promotion h3, #victoryModal h2 {
    color: #81b64c;
    margin-bottom: 25px;
    font-size: 1.6em;
    text-shadow: 0 2px 15px rgba(129, 182, 76, 0.5);
  }

  #promotion button, #victoryModal button {
    font-size: 42px;
    margin: 12px;
    cursor: pointer;
    background: rgba(129, 182, 76, 0.1);
    border: 2px solid #555;
    border-radius: 12px;
    color: #fff;
    padding: 18px 22px;
    transition: all 0.3s ease;
  }

  #promotion button:hover, #victoryModal button:hover {
    transform: scale(1.15);
    background: rgba(129, 182, 76, 0.25);
    border-color: #81b64c;
    box-shadow: 0 0 25px rgba(129, 182, 76, 0.6);
  }

  #victoryModal button {
    font-size: 16px;
    padding: 14px 28px;
    margin: 12px 6px;
  }

  .modal-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.85);
    z-index: 99;
    backdrop-filter: blur(5px);
  }

  .reward-display {
    background: rgba(129, 182, 76, 0.15);
    padding: 15px 20px;
    border-radius: 10px;
    margin-top: 15px;
    border: 2px solid #81b64c;
  }

  .reward-item {
    font-size: 1.3em;
    margin: 8px 0;
    font-weight: 700;
  }

  .bonus-coins {
    color: #ffd700;
    animation: coinShine 2s infinite;
  }

  @keyframes coinShine {
    0%, 100% { text-shadow: 0 0 10px #ffd700; }
    50% { text-shadow: 0 0 20px #ffd700; }
  }

  @media (max-width: 968px) {
    #board {
      grid-template-columns: repeat(8, 55px);
      grid-template-rows: repeat(8, 55px);
    }
    
    .square {
      width: 55px;
      height: 55px;
      font-size: 36px;
    }

    h1 {
      font-size: 1.9em;
    }

    .game-container {
      flex-direction: column;
    }
  }
</style>
</head>
<body>

<h1>‚ôüÔ∏è Chess Ult - Modo IA</h1>

<div class="game-container">
  <div class="left-panel">
    <div class="game-info">
      <div class="info-row">
        <span class="info-label">üë§ Jogador</span>
        <span class="info-value" id="playerName"></span>
      </div>
      <div class="info-row">
        <span class="info-label">üß© ELO</span>
        <span class="info-value" id="playerElo"></span>
      </div>
      <div class="info-row">
        <span class="info-label">ü™ô Moedas</span>
        <span class="info-value" id="playerCoins"></span>
      </div>
    </div>

    <div class="timer-display">
      <div class="label">‚è±Ô∏è Tempo de Jogo</div>
      <div class="time" id="gameTimer">00:00</div>
    </div>
  </div>

  <div>
    <div id="board"></div>
    <div id="turn">Vez das brancas ‚ö™</div>

    <div class="button-container">
      <button id="restart">üîÑ Reiniciar</button>
      <button id="equipCannon">üß® Equipar Canh√£o</button>
      <button id="backToMenu">üè† Menu</button>
    </div>
  </div>
</div>

<div class="modal-overlay" id="modalOverlay"></div>

<div id="promotion">
  <h3>üéØ Promo√ß√£o de Pe√£o</h3>
  <div id="promoButtons"></div>
</div>

<div id="victoryModal"></div>

<script>
const board = document.getElementById("board");
const turnText = document.getElementById("turn");
const restartBtn = document.getElementById("restart");
const equipBtn = document.getElementById("equipCannon");
const backBtn = document.getElementById("backToMenu");
const promotionDiv = document.getElementById("promotion");
const promoButtons = document.getElementById("promoButtons");
const victoryModal = document.getElementById("victoryModal");
const modalOverlay = document.getElementById("modalOverlay");
const timerDisplay = document.getElementById("gameTimer");

let boardState = [];
let selected = null;
let currentPlayer = "white";
let gameOver = false;
let promoPos = null;
let lastMove = null;
let cannonEquipped = false;
let gameStartTime = null;
let timerInterval = null;
let elapsedSeconds = 0;

// Jogador e invent√°rio
const user = localStorage.getItem("currentUser");
if (!user) {
  window.location.href = "index.html";
}

let players = JSON.parse(localStorage.getItem("players")) || {};
const currentUserData = players[user];

// Exibir informa√ß√µes do jogador
document.getElementById("playerName").textContent = user;
document.getElementById("playerElo").textContent = currentUserData?.elo || 1000;
document.getElementById("playerCoins").textContent = currentUserData?.coins || 0;

// Verificar se tem canh√£o
const hasCannon = currentUserData && currentUserData.inventory && currentUserData.inventory.includes("cannon");
if (hasCannon) {
  equipBtn.style.display = "inline-block";
}

equipBtn.onclick = () => {
  if (!cannonEquipped) {
    // Canh√£o substitui a torre na posi√ß√£o inicial
    boardState[7][0] = "üß®";
    cannonEquipped = true;
    equipBtn.disabled = true;
    equipBtn.textContent = "‚úì Equipado";
    equipBtn.style.opacity = "0.6";
    renderBoard();
    alert("üß® Canh√£o equipado! Move-se como torre e pode lan√ßar pe√µes adjacentes 3 casas √† frente!");
  }
};

backBtn.onclick = () => {
  if (confirm("Deseja sair da partida? O progresso ser√° perdido.")) {
    stopTimer();
    window.location.href = "menu.html";
  }
};

// Timer
function startTimer() {
  gameStartTime = Date.now();
  timerInterval = setInterval(() => {
    elapsedSeconds = Math.floor((Date.now() - gameStartTime) / 1000);
    const minutes = Math.floor(elapsedSeconds / 60);
    const seconds = elapsedSeconds % 60;
    timerDisplay.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
  }, 1000);
}

function stopTimer() {
  if (timerInterval) {
    clearInterval(timerInterval);
    timerInterval = null;
  }
}

// Calcular moedas b√¥nus baseado no tempo
function calculateCoinBonus(seconds) {
  const baseCoins = 10;
  let bonus = 0;
  
  if (seconds < 60) bonus = 50;
  else if (seconds < 120) bonus = 40;
  else if (seconds < 180) bonus = 30;
  else if (seconds < 300) bonus = 20;
  else if (seconds < 600) bonus = 10;
  
  return baseCoins + bonus;
}

// Tabuleiro inicial
const initialBoard = [
  ["‚ôú", "‚ôû", "‚ôù", "‚ôõ", "‚ôö", "‚ôù", "‚ôû", "‚ôú"],
  ["‚ôü", "‚ôü", "‚ôü", "‚ôü", "‚ôü", "‚ôü", "‚ôü", "‚ôü"],
  ["", "", "", "", "", "", "", ""],
  ["", "", "", "", "", "", "", ""],
  ["", "", "", "", "", "", "", ""],
  ["", "", "", "", "", "", "", ""],
  ["‚ôô", "‚ôô", "‚ôô", "‚ôô", "‚ôô", "‚ôô", "‚ôô", "‚ôô"],
  ["‚ôñ", "‚ôò", "‚ôó", "‚ôï", "‚ôî", "‚ôó", "‚ôò", "‚ôñ"]
];

boardState = JSON.parse(JSON.stringify(initialBoard));

function getColor(piece) {
  if (!piece) return null;
  return "‚ôô‚ôñ‚ôò‚ôó‚ôï‚ôîüß®".includes(piece) ? "white" : "black";
}

function getPieceValue(piece) {
  const values = {
    "‚ôô": 1, "‚ôü": 1,
    "‚ôò": 3, "‚ôû": 3,
    "‚ôó": 3, "‚ôù": 3,
    "‚ôñ": 5, "‚ôú": 5,
    "üß®": 6,
    "‚ôï": 9, "‚ôõ": 9,
    "‚ôî": 1000, "‚ôö": 1000
  };
  return values[piece] || 0;
}

function renderBoard() {
  board.innerHTML = "";
  
  for (let i = 0; i < 8; i++) {
    for (let j = 0; j < 8; j++) {
      const sq = document.createElement("div");
      sq.classList.add("square", (i + j) % 2 === 0 ? "light" : "dark");
      sq.dataset.row = i;
      sq.dataset.col = j;

      const piece = boardState[i][j];
      if (piece) {
        const span = document.createElement("span");
        span.textContent = piece;
        sq.appendChild(span);
      }

      if (piece === "‚ôö" || piece === "‚ôî") {
        checkKingInDanger(i, j, sq);
      }

      if (lastMove && ((lastMove.from[0] === i && lastMove.from[1] === j) || 
          (lastMove.to[0] === i && lastMove.to[1] === j))) {
        sq.classList.add("last-move");
      }

      sq.onclick = () => handleClick(i, j);
      board.appendChild(sq);
    }
  }
}

function checkKingInDanger(r, c, sq) {
  const kingColor = getColor(boardState[r][c]);
  if (isSquareThreatened(r, c, kingColor)) {
    sq.classList.add("king-in-check");
  }
}

function isSquareThreatened(r, c, color) {
  for (let i = 0; i < 8; i++) {
    for (let j = 0; j < 8; j++) {
      const p = boardState[i][j];
      if (p && getColor(p) !== color) {
        if (isValidMove(i, j, r, c, false)) return true;
      }
    }
  }
  return false;
}

function isKingInCheck(color) {
  for (let i = 0; i < 8; i++) {
    for (let j = 0; j < 8; j++) {
      const piece = boardState[i][j];
      if ((piece === "‚ôî" && color === "white") || (piece === "‚ôö" && color === "black")) {
        return isSquareThreatened(i, j, color);
      }
    }
  }
  return false;
}

function wouldMoveCauseCheck(sr, sc, tr, tc, color) {
  const originalPiece = boardState[tr][tc];
  const movingPiece = boardState[sr][sc];
  
  boardState[tr][tc] = movingPiece;
  boardState[sr][sc] = "";
  
  const inCheck = isKingInCheck(color);
  
  boardState[sr][sc] = movingPiece;
  boardState[tr][tc] = originalPiece;
  
  return inCheck;
}

function handleClick(row, col) {
  if (gameOver || currentPlayer === "black") return;
  
  const piece = boardState[row][col];
  
  if (selected) {
    const [sr, sc] = selected;
    if (isValidMove(sr, sc, row, col, true)) {
      movePiece(sr, sc, row, col);
      selected = null;
      
      if (!gameOver && !promoPos) {
        currentPlayer = "black";
        turnText.textContent = "Vez das pretas ‚ö´";
        setTimeout(aiMove, 600);
      }
    } else {
      selected = null;
      renderBoard();
    }
  } else if (piece && getColor(piece) === "white") {
    selected = [row, col];
    renderBoard();
    
    const targetSquare = board.children[row * 8 + col];
    targetSquare.classList.add("highlight");
    
    const moves = getMoves(row, col);
    moves.forEach(m => {
      const sq = board.children[m[0] * 8 + m[1]];
      const dot = document.createElement("div");
      dot.classList.add("possible-move");
      
      if (boardState[m[0]][m[1]]) {
        dot.classList.add("possible-capture");
      }
      
      // Marcar lan√ßamento de canh√£o
      if (m[2] === "cannonLaunch") {
        dot.classList.add("cannon-launch");
      }
      
      sq.appendChild(dot);
    });
  }
}

function movePiece(sr, sc, tr, tc) {
  const target = boardState[tr][tc];
  
  if (target === "‚ôö" || target === "‚ôî") {
    gameOver = true;
    stopTimer();
    showVictory(currentPlayer);
    return;
  }
  
  lastMove = { from: [sr, sc], to: [tr, tc] };
  boardState[tr][tc] = boardState[sr][sc];
  boardState[sr][sc] = "";

  if ((boardState[tr][tc] === "‚ôô" && tr === 0) || (boardState[tr][tc] === "‚ôü" && tr === 7)) {
    promoPos = [tr, tc];
    openPromotion(boardState[tr][tc]);
    return;
  }

  renderBoard();
}

function openPromotion(piece) {
  modalOverlay.style.display = "block";
  promotionDiv.style.display = "block";
  promoButtons.innerHTML = "";
  
  const isWhite = getColor(piece) === "white";
  const options = isWhite ? ["‚ôï", "‚ôñ", "‚ôó", "‚ôò"] : ["‚ôõ", "‚ôú", "‚ôù", "‚ôû"];
  const names = ["Rainha", "Torre", "Bispo", "Cavalo"];
  
  options.forEach((opt, idx) => {
    const btn = document.createElement("button");
    btn.textContent = opt;
    btn.title = names[idx];
    btn.onclick = () => {
      boardState[promoPos[0]][promoPos[1]] = opt;
      promotionDiv.style.display = "none";
      modalOverlay.style.display = "none";
      promoPos = null;
      
      currentPlayer = currentPlayer === "white" ? "black" : "white";
      turnText.textContent = `Vez das ${currentPlayer === "white" ? "brancas ‚ö™" : "pretas ‚ö´"}`;
      renderBoard();
      
      if (currentPlayer === "black") setTimeout(aiMove, 600);
    };
    promoButtons.appendChild(btn);
  });
}

function isValidMove(sr, sc, tr, tc, checkKing = true) {
  if (sr === tr && sc === tc) return false;
  
  const piece = boardState[sr][sc];
  const target = boardState[tr][tc];
  const pieceColor = getColor(piece);
  const targetColor = getColor(target);
  
  if (targetColor === pieceColor) return false;
  
  if (checkKing && wouldMoveCauseCheck(sr, sc, tr, tc, pieceColor)) {
    return false;
  }
  
  const dr = tr - sr;
  const dc = tc - sc;
  
  switch (piece) {
    case "‚ôô":
      if (dc === 0 && !target && (dr === -1 || (dr === -2 && sr === 6 && !boardState[sr - 1][sc]))) return true;
      if (Math.abs(dc) === 1 && dr === -1 && targetColor === "black") return true;
      break;
      
    case "‚ôü":
      if (dc === 0 && !target && (dr === 1 || (dr === 2 && sr === 1 && !boardState[sr + 1][sc]))) return true;
      if (Math.abs(dc) === 1 && dr === 1 && targetColor === "white") return true;
      break;
      
    case "‚ôñ":
    case "‚ôú":
      if (sr === tr || sc === tc) return clearPath(sr, sc, tr, tc);
      break;
      
    case "‚ôó":
    case "‚ôù":
      if (Math.abs(dr) === Math.abs(dc)) return clearPath(sr, sc, tr, tc);
      break;
      
    case "‚ôï":
    case "‚ôõ":
      if (sr === tr || sc === tc || Math.abs(dr) === Math.abs(dc)) return clearPath(sr, sc, tr, tc);
      break;
      
    case "‚ôò":
    case "‚ôû":
      if ((Math.abs(dr) === 2 && Math.abs(dc) === 1) || (Math.abs(dr) === 1 && Math.abs(dc) === 2)) return true;
      break;
      
    case "‚ôî":
    case "‚ôö":
      if (Math.abs(dr) <= 1 && Math.abs(dc) <= 1) return true;
      break;
      
    case "üß®":
      // Canh√£o move como torre
      if (sr === tr || sc === tc) return clearPath(sr, sc, tr, tc);
      break;
  }
  
  return false;
}

function clearPath(sr, sc, tr, tc) {
  const stepR = Math.sign(tr - sr);
  const stepC = Math.sign(tc - sc);
  let r = sr + stepR;
  let c = sc + stepC;
  
  while (r !== tr || c !== tc) {
    if (boardState[r][c]) return false;
    r += stepR;
    c += stepC;
  }
  
  return true;
}

function canCannonLaunchPawn(cannonRow, cannonCol, pawnRow, pawnCol) {
  // Canh√£o deve estar ao lado do pe√£o (mesma linha, colunas adjacentes)
  if (cannonRow === pawnRow && Math.abs(cannonCol - pawnCol) === 1) {
    const pawn = boardState[pawnRow][pawnCol];
    const cannon = boardState[cannonRow][cannonCol];
    
    // Ambos devem ser brancos
    if (getColor(pawn) === "white" && getColor(cannon) === "white") {
      // Pe√£o pode ser lan√ßado 3 casas √† frente
      if (pawn === "‚ôô") {
        const targetRow = pawnRow - 3;
        if (targetRow >= 0 && !boardState[targetRow][pawnCol] && 
            !boardState[pawnRow - 1][pawnCol] && !boardState[pawnRow - 2][pawnCol]) {
          return true;
        }
      }
    }
  }
  return false;
}

function getMoves(r, c) {
  const moves = [];
  const piece = boardState[r][c];
  
  for (let i = 0; i < 8; i++) {
    for (let j = 0; j < 8; j++) {
      if (isValidMove(r, c, i, j, true)) {
        moves.push([i, j]);
      }
    }
  }
  
  // Adicionar lan√ßamento de canh√£o se aplic√°vel
  if (piece === "üß®") {
    for (let j = 0; j < 8; j++) {
      const adjacentPiece = boardState[r][j];
      if (adjacentPiece === "‚ôô" && canCannonLaunchPawn(r, c, r, j)) {
        const targetRow = r - 3;
        moves.push([targetRow, j, "cannonLaunch"]);
      }
    }
  }
  
  // Se uma pe√ßa est√° ao lado do canh√£o
  if (piece === "‚ôô") {
    // Verificar se h√° um canh√£o adjacente
    const adjacentPositions = [[r, c-1], [r, c+1]];
    for (let [ar, ac] of adjacentPositions) {
      if (ac >= 0 && ac < 8 && boardState[ar][ac] === "üß®") {
        if (canCannonLaunchPawn(ar, ac, r, c)) {
          const targetRow = r - 3;
          moves.push([targetRow, c, "cannonLaunch"]);
          break;
        }
      }
    }
  }
  
  return moves;
}

function evaluateMove(move) {
  const { from, to } = move;
  const [sr, sc] = from;
  const [tr, tc] = to;
  
  let score = 0;
  
  const target = boardState[tr][tc];
  if (target) {
    score += getPieceValue(target) * 10;
  }
  
  // Penalizar se deixar o rei em xeque
  if (wouldMoveCauseCheck(sr, sc, tr, tc, "black")) {
    score -= 1000;
  }
  
  // Bonificar se escapar de xeque
  if (isKingInCheck("black") && !wouldMoveCauseCheck(sr, sc, tr, tc, "black")) {
    score += 500;
  }
  
  // Bonificar avan√ßo de pe√µes
  if (boardState[sr][sc] === "‚ôü" && tr > sr) {
    score += (tr - sr) * 2;
  }
  
  // Bonificar controle do centro
  if ((tr === 3 || tr === 4) && (tc >= 2 && tc <= 5)) {
    score += 5;
  }
  
  // Verificar se a pe√ßa ficaria amea√ßada ap√≥s o movimento
  const originalPiece = boardState[tr][tc];
  const movingPiece = boardState[sr][sc];
  boardState[tr][tc] = movingPiece;
  boardState[sr][sc] = "";
  
  if (isSquareThreatened(tr, tc, "black")) {
    score -= getPieceValue(movingPiece) * 5;
  }
  
  boardState[sr][sc] = movingPiece;
  boardState[tr][tc] = originalPiece;
  
  return score;
}

function aiMove() {
  if (gameOver) return;
  
  const moves = [];
  for (let i = 0; i < 8; i++) {
    for (let j = 0; j < 8; j++) {
      const p = boardState[i][j];
      if (p && getColor(p) === "black") {
        const ms = getMoves(i, j);
        ms.forEach(mv => {
          moves.push({ 
            from: [i, j], 
            to: [mv[0], mv[1]], 
            piece: p,
            score: 0
          });
        });
      }
    }
  }
  
  if (moves.length === 0) {
    stopTimer();
    showVictory("white");
    return;
  }

  // Avaliar todos os movimentos
  moves.forEach(move => {
    move.score = evaluateMove(move);
  });
  
  // Ordenar por pontua√ß√£o (maior primeiro)
  moves.sort((a, b) => b.score - a.score);
  
  // Filtrar movimentos que n√£o causam xeque no pr√≥prio rei
  const safeMoves = moves.filter(mv => mv.score > -900);
  
  const bestMoves = safeMoves.length > 0 ? safeMoves : moves;
  
  // Escolher entre os 3 melhores movimentos (adiciona varia√ß√£o)
  const topMoves = bestMoves.slice(0, Math.min(3, bestMoves.length));
  const choice = topMoves[Math.floor(Math.random() * topMoves.length)];
  
  movePiece(choice.from[0], choice.from[1], choice.to[0], choice.to[1]);
  
  if (!gameOver && !promoPos) {
    currentPlayer = "white";
    turnText.textContent = "Vez das brancas ‚ö™";
  }
}

function showVictory(winner) {
  gameOver = true;
  modalOverlay.style.display = "block";
  
  let text = winner === "white" ? "üèÜ Vit√≥ria!" : "üò¢ Derrota";
  let rewardsHTML = "";
  
  if (winner === "white") {
    const coinBonus = calculateCoinBonus(elapsedSeconds);
    const eloGain = 50;
    
    currentUserData.elo = (currentUserData.elo || 1000) + eloGain;
    currentUserData.coins = (currentUserData.coins || 0) + coinBonus;
    players[user] = currentUserData;
    localStorage.setItem("players", JSON.stringify(players));
    
    const minutes = Math.floor(elapsedSeconds / 60);
    const seconds = elapsedSeconds % 60;
    const timeStr = `${minutes}:${String(seconds).padStart(2, '0')}`;
    
    rewardsHTML = `
      <div class="reward-display">
        <div class="reward-item">‚è±Ô∏è Tempo: ${timeStr}</div>
        <div class="reward-item">üß© +${eloGain} ELO</div>
        <div class="reward-item bonus-coins">ü™ô +${coinBonus} moedas</div>
        ${coinBonus > 20 ? '<div style="color: #ffd700; margin-top: 10px;">‚ö° B√¥nus de Velocidade!</div>' : ''}
      </div>
    `;
    
    document.getElementById("playerElo").textContent = currentUserData.elo;
    document.getElementById("playerCoins").textContent = currentUserData.coins;
  }
  
  victoryModal.innerHTML = `
    <h2>${text}</h2>
    ${rewardsHTML}
    <div style="margin-top: 25px;">
      <button onclick="restartGame()">üîÑ Jogar Novamente</button>
      <button onclick="exitGame()">üè† Voltar ao Menu</button>
    </div>
  `;
  victoryModal.style.display = "block";
}

function restartGame() {
  victoryModal.style.display = "none";
  modalOverlay.style.display = "none";
  boardState = JSON.parse(JSON.stringify(initialBoard));
  lastMove = null;
  currentPlayer = "white";
  gameOver = false;
  cannonEquipped = false;
  elapsedSeconds = 0;
  
  if (hasCannon) {
    equipBtn.disabled = false;
    equipBtn.textContent = "üß® Equipar Canh√£o";
    equipBtn.style.opacity = "1";
  }
  
  turnText.textContent = "Vez das brancas ‚ö™";
  timerDisplay.textContent = "00:00";
  renderBoard();
  startTimer();
}

function exitGame() {
  window.location.href = "menu.html";
}

restartBtn.onclick = () => {
  if (confirm("Reiniciar a partida?")) {
    stopTimer();
    restartGame();
  }
};

// Inicializar jogo
renderBoard();
startTimer();
</script>
</body>
</html>
